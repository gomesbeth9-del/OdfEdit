"""
-------------------------------------------------------------------------------
 Name:        OdfEdit
 Purpose:     Application helping to edit in plain text an organ definition file (ODF)
              made for the GrandOrgue application (see github.com/GrandOrgue/grandorgue)
              and allowing to convert a Hauptwerk ODF into GrandOrgue ODF
              Implemented with Python 3.1x
              Tested in Windows and Ubuntu
              It is contains following classes :
                   C_LOGS to manage the logs generated by the various fonctions of the application
                   C_AUDIO_PLAYER to play audio files (wave or wavpack format)
                   C_ODF_MISC to manage miscellaneous feature of an ODF (compass extension for example)
                   C_ODF_DATA_CHECK to check the syntax and the consistency of the edited ODF data
                   C_ODF_DATA to manage the edited ODF data
                   C_ODF_HW2GO to do the conversion from a Hauptwerk ODF to a GrandOrgue ODF
                   C_GUI_NOTEBOOK to manage the notebook widget and its tabs content in the GUI of the application
                   C_GUI to manage the graphical user interface of the application
                   ToolTip to display a tool tip on a GUI widget
                   AskUserChooseListItems to manage a dialog window asking the user to choose items in a list
                   AskUserAnswerQuestion to manage a dialog window asking the user to answer to a question by pressing buttons
                   AskUserEnterString to manage a dialog window asking the user to enter a string

 Author:      Eric Turpault (France, Ch√¢tellerault)
 Copyright:   open source
 Licence:     MIT licence, please share the modifications with the author

 The considered GrandOrgue ODF syntax is :
    [object_uid]  ; comment, section name (object_uid, object unique id) can contain only alphanumeric characters
    ; comment line, empty lines are ignored
    attribute1=value1  ; comment, attribute field can contain only alphanumeric or '_' characters
    attribute2=value2

 The new panel format is detected if the Panel000 section is present and contains the attribute NumberOfGUIElements

 Versions history :
   v1.0 - 15 April 2022 - initial version
   v1.1 - 16 April 2022 - minor changes to be Linux compatible, minor GUI fixes
   v1.2 - 27 April 2022 - some GUI behavior improvements, minor improvements in the help and the objects checks
   v1.3 - 19 May   2022 - data management improvement, change in the way to define the parent-child relations between the objects,
                          completed some attributes values maximum check, added a tab to search a string in the whole ODF
   v2.0 - 23 Dec.  2022 - fix made in the function check_object_Manual around the key_type checks
                          fix made in the function check_attribute_value to not change out of range integer value and better check HTML color code
                          use the PIL library instead of Tk to check the sample set images sizes
                          first implementation of the Hauptwerk to GrandOrgue ODF conversion feature
   v2.1 - 22 Dec.  2023 - HW2GO : fix for files path separator management in various OS
                          HW2GO : get the actual files path/name/extension case from the HW sample set instead of from the HW ODF
                          HW2GO : some design changes without functional impact
                          HW2GO : added general sound stops (blower, bells, ...) and stop action noise support
   v2.2 - 12 Jan. 2023  - HW2GO : improved and more robust way to detect Stop / Coupler / Switch objects to build
                          HW2GO : fix of issues observed with some newly tested HW sample sets
                          HW2GO : added support of HW continuous control and enclosure objects, converted into GO enclosure objects
                          GUI : graphical user interface rework with resizable width for lists and notebook areas
                          GUI : Organ object placed systematically at the top of the objects list
   v2.3 - 08 April 2023 - fix for help text not loaded with Windows OdfEdit.exe (fix in file Help.txt due to characters 0x81 not supported by unicode format)
                          add the support of comments at the end of the lines in the ODF
                          add the support of the separator / in the files path in the ODF
                          improved display and selection of parents/children objects of the selected object
                          improved several behaviors in the GUI management
                          ODF saving in a file places the objects by alphabetical UID order, but Header and Organ which are placed in first position
                          new buttons to add, link to parents/children or rename an object, with automatical update of the object referencing
                             and the total number in other objects, new panel format only is supported
                          HW2GO : visual elements of the main panel are now defined in Panel999Element999 objects
                          HW2GO : Switches have by default StoreInDivisional=Y, StoreInGeneral=Y, GCState=0
                          HW2GO : added a menu item checkbox to ask to convert to GO ranks the HW ranks not used by OdfEdit
   v2.4 - 30 May 2023   - objects having child(ren) cannot be deleted with the button Delete
                          added a menu item checkbox to select the file format to use when saving an ODF (ISO_8859_1 or UTF-8 BOM)
                          added a menu item checkbox to disable the automatic objects tree expand on object selection
                          added a menu item checkbox to enable the wave based tremulants conversion from HW to GO
                          added a menu item checkbox to enable the unused ranks conversion from HW to GO
                          configuration data of the application (last ODF folder, options of the menu) are saved in a file OdfEdit.cfg
                          improvements made in the objects list/tree behavior on object selection or change
                          the parents/children of the selected object can be selected and edited in the central list (above the text editor)
                          a double-click on a parent/child object makes it the selected object in the list/tree
                          ctrl+s keys permits to save changes in the edited object and to save changed data in the ODF
                          escape key permits to close the pop-up windows permitting to select parent/children objects
                          added the possiblity to search a text inside the loaded HW ODF
                          HW2GO : removed the attribute AcceptRetuning=N in ranks of pipes
                          HW2GO : pitch tuning attribute used for pipes which the sample has a different native frequency
                          HW2GO : convert the conditional switches (switches which the state depends on the state of other switches)
                          HW2GO : convert the synthetized and wave based tremulants
                          HW2GO : the stop and coupler objects are numeroted according to the manual number to which they belong to
                          several bugs fixing as at each release
   v2.5 - 26 Aug. 2023  - manage drag&drop of one object (type : Coupler, Enclosure, PanelElement, PanelImage, Rank, Stop, Tremulant)
                            between the objects lists or tree, in order to move it under another parent object
                          drag&drop with Control key pressed adds a copy of the dragged object as child of the object on which the drop has been done
                          Ctrl-a in object edition or logs text boxes permits to selected all the text (needed for Linux)
                          paste in object edition text box replaces the current selected text if any (needed for Linux)
                          mouse double click in object edition text box selects the text until the equal or brackets character
                          added the possibility to search in the ODF in a selected range (ODF, selected object, children of the selected object)
                          added the possibility to search in the ODF with a regular expression
                          added the possibility to replace the text found by the search
                          "object" renamed to "section" in the GUI
                          HW2GO : check that the mouse or text rectangle doesn't exceed the image size of a switch or label
                          HW2GO : unused HW noise ranks are converted to GO ranks if the conversion option is enabled in the menu
                          HW2GO : add in a switch or setter the text of a label which is overlapping it
                          HW2GO : rework of the way to calculate the rank related attributes in the Stop object (pipes stop)
                          HW2GO : update the organ / pipes pitch tuning calculation
                          HW2GO : manage the case where there are more than 99 stops in a manual
                          HW2GO : manage the case where one enclosure is controlled from several panel element objects
                          HW2GO : add the Loop/ReleaseCrossfadeLength attributes conversion in the ranks (clipped to GO max values waiting for GO 3.13.0)
                          HW2GO : use TextBreakWidth=0 instead of DispLabelText= to have no text displayed in a button or enclosure
                          several minor improvements and bugs fixing
   v2.6 - 13 Oct. 2023  - added a Viewer tab to view or play the selected file in the editor
                          HW2GO : Loop/ReleaseCrossfadeLength maximum value set at 3000 (needs GO 3.13.0-1)
   v2.7 - 07 Nov. 2023  - manage in the viewer the pipe borrowing format REF:xx:xx:xx + minor improvements
                          HW2GO : manage the keyboards noises conversion
                          HW2GO : add in manual sections the reference to the associated stop/coupler/tremulant switches
                          HW2GO : place the wave tremmed samples in the same rank as the not tremmed samples if selected in a new menu option
                          HW2GO : noise samples gains lower than -5 are set at -5
                          several minor improvements and bugs fixing
   v2.8 - 18 Nov. 2023  - improvement of the section drag&drop visual behavior
                          drag&drop permits to reorder between them sections of the same type
                          removal of the menu option asking to auto expand sections tree on section selection. Double clicking on an item of sections list makes expand the sections tree to show the selected section.
                          HW2GO : convert alternate screen layouts into GO panels if selected in a new dedicated menu option
                          some minor improvements and bugs fixing
   v2.9 - 01 Feb. 2024  - display the number of found occurrences in Search results
                          when a Panel section is deleted all his children Panelxxxx sections are deleted as well
                          any section can be deleted, a warning message is displayed if the section to delete has children sections
                          add the check of attributes Pipe999Attack999LoopCrossfadeLength, Pipe999Attack999ReleaseCrossfadeLength, Pipe999Release999ReleaseCrossfadeLength
                          fix made in the check of PanelElement section
                          add a menu item permitting to sort in the selected section the references to other sections
                          rework of the function doing references sorting in a section
                          sections referenced in General and Divisional sections are no more considered as their children
                          PanelElement sections are now child instead of parent of the section they are refering to
                          use sounddevice library instead of audioplayer library, which reduces OdfEdit Linux binary by 21MB. WavPack files cannot be played anymore in the viewer
                          HW2GO : use the new attributes Pipe999Attack999LoopCrossfadeLength and Pipe999Release999ReleaseCrossfadeLength introduced in GO 3.14.0
                          HW2GO : set the attribute MIDIInputNumber in objects Manual and Enclosure (if real enclosure)
                          HW2GO : insert the conversion date in the generated ODF (header and organ comment)
                          HW2GO : improve the Tremulant to WindchestGroup linkage method
                          HW2GO : fix for negative pipe gain not being converted
                          HW2GO : fix an issue in enclosures linkage parsing
                          some minor improvements and bugs fixing
   v2.10 - 17 March 2024- add the check of attributes HasIndependentRelease and Pipe999HasIndependentRelease
                          when a section is deleted, rearrange the ID of other sections of the same type so that the IDs are increasing continuously without gap
                            this is applicable only for following sections types : Enclosure, General, Panel, PanelElement, PanelImage, Rank, Switch, Tremulant, WindchestGroup
                          improve the metadata presentation in the wave file viewer
                          HW2GO : added a menu option to not convert keys noises
                          HW2GO : added two menu options to make pipes pitch correction when needed, based on sample metadata or file name MIDI note
                          HW2GO : fix wrong manual/stop attributes when a manual does not start with MIDI note 36
                          HW2GO : manage unusual key to pipe MIDI note mapping
                          HW2GO : convert the pipe attack minimum velocity attribute
                          HW2GO : do not convert attack samples which the selectability is based on a continuous control state
                          HW2GO : manage the case where a windchest has more than one volume control slider
                          HW2GO : manage the case where keys noises are defined for several audio channels
                          HW2GO : disable temporarily the CrossfadeLength attributes conversion waiting for GO 3.14.0 to be released officially
                          several code and logic improvements
   v2.11 - 14 April 2024- integrate in the help the changes made in GO 3.14.0 help
                          add the check of attributes added/modified in GO 3.14.0
                          on application start restore the last window size and position, and sub-areas dimensions
                          HW2GO : improve the way to convert tremmed samples when they have to be placed in separate ranks
                          HW2GO : restore the usage of the attributes Pipe999Attack999LoopCrossfadeLength and Pipe999Release999ReleaseCrossfadeLength
                          HW2GO : manage the case where a file path contains // instead of /
                          HW2GO : set GCState=-1 in the Stop sections containing keys noises, to let them engaged after a General Cancel push
                          HW2GO : redesign of the way to identify the HW objects to convert in GO Stop / Coupler / Tremulant / Switch / Setter objects
                          HW2GO : usage of the new attribute HasIndependentRelease to group inside a unique Stop section attack and release samples of each noise and audio channel
                          some minor improvements and bugs fixing
   v2.12 - 31 May 2024  - new graphical interface colors, unified between main window and pop-up windows
                          clickable widgets have their background color changing on mouse cursor hovering
                          add a button to open an ODF from the recently opened ODFs list
                          add a menu item to clear the recently opened ODFs list
                          menu stays opened when clicking on a checkable option
                          add a check button to make case insensitive the search in the ODF
                          Collapse and Expand buttons act on the selected section of the sections tree and no longer on the entire tree
                          The viewer can render files (images, audio samples) selected in the HW sections
                          HW2GO : redesign of the way to build the switches network
                          HW2GO : optimization in the HW sections tree building and switches network, reducing significantly the conversion time
                          HW2GO : rework the way to map the HW Keyboard / Division to GO Manual sections
                          HW2GO : added in the header of the GO ODF information about the chosen conversion options
                          HW2GO : use a pitch specification method code in each sample to know if their pitch has to be read from the metadata of the sample file
                          HW2GO : in ranks, set an harmonic number value at rank level, and at pipe level set only if it is different from the one at rank level
                          HW2GO : conversion of HW Combination into GO General/Divisional and master capture (SET) and general cancel
                          HW2GO : set the Enclosure attribute AmpMinimumLevel at 0 instead of 1 as GO 3.14.3 does not mute anymore pipes after enclosure set to 0 and then reopened
   v2.13 - 23 June 2024 - The search is case insensitive by default (instead of case sensitive by default before)
                          Pressing the Delete key of the keyboard does the same action as clicking on the Delete button
                          Adding a button to clear the search&replace data
                          HW2GO : fixing an issue with the attribute DefaultToEngaged=N not set when required, preventing the generated ODF to be loaded in GO
                          HW2GO : improving the manual keys building to support any kind of first and last key note (sharp notes included) when the keys aspect is defined at octave level
                          HW2GO : converting the tremmed samples in the way they are defined in Piotr Grabowski sample sets (placed in second pipes layers and not in alternate ranks as done by Sonus Paradisi)
   v2.14 - 22 Sept 2024 - The Delete key pressing deletes the selected section only if the focus is in a sections list or tree
                          Implementation of a manual / stop / rank compass extension feature (accessible from a menu item)
   v2.15 - 11 Nov 2024  - Adding a button "Reload" to reload from the storage the ODF currently opened (to discard changes made in the ODF and not saved yet)
                          The compass extension at Manual level is defined with the new number of keys instead of the new maximum MIDI note
                          Bug fix in rank compass extension where the gain was not considered as a float value
                          Improvement of the viewer's features :
                            - the viewer is inactive when its tab is not selected
                            - the images zoom/unzoom is centered on the mouse cursor position
                            - when a Panel section is selected, all images of its children sections are displayed (images off or first image by default)
                            - when a section having an image is selected, all images of the same panel are displayed with a reduced brightness
                            - when an image file is clicked in the text of a section, this image is displayed and others of the same panel are displayed with a reduced brightness
                              or are not displayed if they are other images of the same manual
                            - if OdfEdit is executed with the Windows executable or in a normal Python process (Windows or Linux), WavPack files can be played.
                              if OdfEdit is executed with the Linux executable, WavPack files cannot be played (this is to avoid to have the size of the OdfEdit executable file increased by 36MB)
                          (the version v10.1.0 at least of the library Pillow must be installed)
   v2.16 - 01 Dec 2024  - Menu button moved at the most left position
                          Button New renamed in Close and move at the right
                          Adding a button "Clone" to clone the selected section in a new section under the same parent section
                          Adding a button "File picker" permitting to set in the text editor the file of the attribute on which is placed the insertion cursor
                          Adding "undo" / "redo" buttons in the text editor
                          Grouping the buttons "Apply changes", "Undo", "Redo", "File picker" and "Help" in a new buttons bar at the top of the text editor
                          Adding a contextual menu in the logs area, displayed on mouse right click, permitting to clear logs or to select the section which the name is under the mouse cursor
                          Improvement of the ODF Reload processing to make it faster
                          Fixes and improvements in the ODF data check feature
                          Performance improvements in the ODF data processing
                          The search in the help can be done with regular expressions or with case unsensitive/sensitive. The index of the focused found occurrence is displayed.
                          Improvements of the images viewer's features :
                            - a right click on an image permits to select/unselect it and its section in the text editor and the list/tree
                            - a right click drag on an image permits to move it and update consequently its coordinates in the text editor
                            - the zoom-in has more effect than the zoom-out
                          HW2GO : files not found in the sample set folders are converted all the same in the GO ODF if they are not addressing Hauptwerk Standard Components packages
                                  (if their package ID is higher than 10)
   v2.17 - 23 Dec 2024  - Support of multiple sections selection. Drag & drop and Parent/Clone/Delete buttons can act on selected sections. More details in the help.
                          A section referenced in a PanelElement section is its child and no more its parent
   v2.18 - 23 Jan 2025  - Drag & drop with mouse and control key pressed permits to clone the selected sections before/after a hovered section of the same type
                          Improvements in the selection management in sections lists / tree
                          Fixed missing detections of some image definition attributes for the file picker button enabling
                          Fixed a regression in the images viewer not displaying manuals in v2.17
   v2.19 - 18 Apr 2025  - ODF data check : fix related to the NumberOfSwitches attribute of a Panel section
                          ODF data check : fix related to negative values set in CouplerNumber999 and StopNumber999 attributes of a General section
                          HW2GO : supporting the use case where the switch of a keyboard key has no defined image

TO DO LIST :
    ...

-------------------------------------------------------------------------------
"""

APP_VERSION = 'v2.19'
RELEASE_DATE = 'April 18th 2025'

DEV_MODE = False
LOG_HW2GO_drawstop = False
LOG_HW2GO_switch = False
LOG_HW2GO_keys_noise = False
LOG_HW2GO_windchest = False
LOG_HW2GO_manual = False
LOG_HW2GO_rank = False
LOG_HW2GO_perfo = False
LOG_wav_decode = False

import os
import re
import math
import sys
import time
import myint

##import traceback  # call traceback.print_stack(limit=5) in a function to print in the Python console the stack of last 5 calls to this function

from threading import Thread
from datetime  import date

import tkinter as tk                       # already installed with Python on Windows and macOS. Ubuntu/Debian Linux : sudo apt install python3-tk
import tkinter.filedialog as fdialog
import tkinter.font as tkf
from   tkinter import ttk

import sounddevice as sd               # install with : pip install sounddevice
is_audio_player_lib_present = False

from lxml import etree                     # install with : pip install lxml
from PIL  import Image, ImageOps, ImageTk, ImageEnhance    # install with : pip install pillow or pip install -U Pillow (+ if needed : sudo apt-get install python3-pil python3-pil.imagetk)

MAIN_WINDOW_TITLE = 'OdfEdit - ' + APP_VERSION + (' - DEV MODE' if DEV_MODE else '')

# warning message displayed before to start a HW to GO ODF conversion
HW_CONV_MSG = """An ODF will be generated permitting to use in GrandOrgue the Hauptwerk sample set whose you have just chosen the ODF.
None file of the Hauptwerk sample set will be modified.

ATTENTION :
- Please do this operation only with a free Hauptwerk sample set or a not-free sample set that you have duly paid for, and if the editor of this sample set does not preclude its use outside Hauptwerk application.
- With the generated ODF, do not expect to necessarily get with GrandOrgue exactly the same sound rendering and control possibilities as this sample set can have with Hauptwerk."""

# possible ODF file encodings
ENCODING_ISO_8859_1 = 'ISO-8859-1'  # ISO-8859-1
ENCODING_UTF8_BOM   = 'utf_8_sig'   # UTF-8

# characters allowed in a attribute name of the ODF
ALLOWED_CHARS_4_FIELDS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'

# data types used in the attributes of the objects, used in the check object/attribute functions
ATTR_TYPE_INTEGER = 1
ATTR_TYPE_FLOAT = 2
ATTR_TYPE_BOOLEAN = 3
ATTR_TYPE_STRING = 4
ATTR_TYPE_COLOR = 5            # used in Button, Enclosure, Label, Panel
ATTR_TYPE_FONT_SIZE = 6        # used in Button, Enclosure, Label
ATTR_TYPE_PANEL_SIZE = 7       # used in Panel
ATTR_TYPE_COUPLER_TYPE = 8     # used in Coupler
ATTR_TYPE_ELEMENT_TYPE = 9     # used in Panel Element
ATTR_TYPE_TREMULANT_TYPE = 10  # used in Tremulant
ATTR_TYPE_PISTON_TYPE = 11     # used in Piston
ATTR_TYPE_DRAWSTOP_FCT = 12    # used in DrawStop
ATTR_TYPE_FILE_NAME = 13       # used in many objects for bitmap or wave files
ATTR_TYPE_OBJECT_REF = 14      # used in many objects to make a reference to another object ID
ATTR_TYPE_PIPE_WAVE = 15       # used in Rank
ATTR_TYPE_INTEGER_ABS = 16     # check absolute volue of an integer, used in General and Divisional

# notes and octaves constants
NOTES_NAMES  = ['C', 'C#',  'D', 'D#',  'E', 'F', 'F#',  'G', 'G#',  'A', 'A#',  'B']
NOTES_NAMES2 = ['C', 'Cis', 'D', 'Dis', 'E', 'F', 'Fis', 'G', 'Gis', 'A', 'Ais', 'B']
NOTES_NB_IN_OCTAVE = len(NOTES_NAMES)
OCTAVES_RANGE = list(range(-1,10))

# max MIDI note value allowed for the compass extension feature
COMPASS_EXTEND_MAX = 108  # note C8

# constants to identify the type of link between two objects
TO_PARENT = 1
TO_CHILD = 2

# constants to make some functions parameters usage more understandable
FIRST_ONE = True
MANDATORY = True

# GUI colors and fonts
COLOR_BACKGROUND0 = '#E7E7E7'  # background color of the application
COLOR_BACKGROUND1 = '#BFBFBF'  # background color of the selectable widgets when the mouse is not hovering them
COLOR_BACKGROUND2 = '#3396D1'  # background color of the selectable widgets when the mouse is hovering them
COLOR_BG_EDITOR   = 'gray95'
COLOR_BG_LOGS     = 'ivory2'
COLOR_BG_HELP     = 'azure'
COLOR_BG_SEARCH   = 'light yellow'
COLOR_BG_TEXT_SEL = 'snow3'
COLOR_BG_LIST     = 'snow'

TEXT_COLOR     = 'black'
TEXT_FONT      = 'Calibri 11'
TEXT_FONT_BOLD = 'Calibri 11 bold'

# tags and colors for highlightings
TAG_OBJ_UID  = 'tag_obj_uid'  # tag to color the object UID
TAG_FIELD    = 'tag_field'    # tag to color the object fields
TAG_COMMENT  = 'tag_comment'  # tag to color the comments
TAG_TITLE    = 'tag_title'    # tag to color the titles in the help
TAG_FOUND    = 'tag_found'    # tag to color the strings found by the search in the help
TAG_FOUND2   = 'tag_found2'   # tag to color the found string currently highlighted in the help
TAG_SAME_UID = 'tag_same_uid' # tag to color in the objects tree items having same UID as the selected one

COLOR_TAG_OBJ_UID = COLOR_BACKGROUND2
COLOR_TAG_FIELD   = '#AB221D'
COLOR_TAG_COMMENT = '#1E8C03'
COLOR_TAG_TITLE   = '#AB221D'
COLOR_TAG_FOUND   = '#F7ED67'
COLOR_TAG_FOUND2  = '#EDAF04'

COLOR_SELECTED_ITEM = COLOR_BACKGROUND2 # background color for the selected object UID in the lists or tree
COLOR_SAME_UID_ITEM = '#BCE6F2'         # background color for the objects of the lists or tree having the selected object UID but not being selected

VW_MARG = 10  # margin in pixels to have around the images viewer

#-------------------------------------------------------------------------------------------------
class C_LOGS:
    # class to manage logs

    logs_list = [] # list of logs strings (errors or messages resulting from file operation or syntax check or ODF conversion)

    #-------------------------------------------------------------------------------------------------
    def add(self, log_string):
        # add the given string to the events log list
        self.logs_list.append(log_string)

    #-------------------------------------------------------------------------------------------------
    def get(self):
        # recover the logs list
        return self.logs_list

    #-------------------------------------------------------------------------------------------------
    def nb_get(self):
        # recover the number of logs present in the list
        return len(self.logs_list)

    #-------------------------------------------------------------------------------------------------
    def clear(self):
        # clear the log list
        self.logs_list.clear()

# create a global instance of the C_LOGS class
logs = C_LOGS()

#-------------------------------------------------------------------------------------------------
class C_AUDIO_PLAYER:
    # class to extract metadata from wave or wavepack files, and manage audio playback of wav files

    playback_in_progress = False
    playback_paused = False
    playback_to_stop = False

    data_buffer = None
    data_buffer_size = 0
    data_buffer_pos = 0

    stream = None

    samples_nb_per_loop = 1024
    bytes_nb_per_loop = 0

    wavpack_sample_rates = (6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 64000, 88200, 96000, 192000)
    wav_compression_codes = ('Unknown', 'Microsoft PCM', 'Microsoft ADPCM', 'Microsoft IEEE float')

    lib_audio_player = None  # instance of the audioplayer library player

    #-------------------------------------------------------------------------------------------------
    def start(self, file_name):
        # start the audio playback of the given audio file (wave format)
        # return a dictionary with the metadata of the file and the sampled audio data buffer (see the description in wav_data_get function header)

        # if a playback is already in progress, stop it
        self.stop()

        # recover the metadata and sampled audio data of the audio file
        data_dic = self.wav_data_get(file_name)

        # the audioplayer library is not present, use the OdfEdit audio player (which cannot play WavPack audio files)
        if data_dic['error_msg'] == '' and len(data_dic['sampled_data']) > 0:
            # the given file has been decoded without error and the extracted buffer has audio samples inside

            # initialize the data of the playback
            self.playback_in_progress = True
            self.playback_paused = False
            self.playback_to_stop = False
            self.bytes_nb_per_loop = int(self.samples_nb_per_loop * data_dic['nb_of_channels'] * data_dic['bits_per_sample'] / 8)
            self.data_buffer = data_dic['sampled_data']
            self.data_buffer_size = data_dic['audio_data_size']
            self.data_buffer_pos = 0

            # get the size of the samples according to the compression code
            dtypes_int_list = (None, 'int8', 'int16', 'int24', 'int32')
            if data_dic['compression_code'] == 1:  # WAVE_FORMAT_PCM
                dtype = dtypes_int_list[data_dic['bits_per_sample'] // 8]
            elif data_dic['compression_code'] == 3:  # WAVE_FORMAT_IEEE_FLOAT
                dtype = 'float32'
            else:
                dtype = None

            if dtype != None:
                # create and start an audio output stream
                try:
                    self.stream = sd.RawOutputStream(samplerate=data_dic['sampling_rate'],
                                                     channels=data_dic['nb_of_channels'],
                                                     dtype=dtype,
                                                     blocksize=self.samples_nb_per_loop)
                except (sd.PortAudioError, OSError) as err:
                    # an error occurred while opening the PortAudio stream
                    data_dic['error_msg'] = format(err)
                else:
                    # start the PortAudio stream
                    self.stream.start()
                    # lauch the thread managing the audio samples playback in the loop function
                    Thread(target = self.loop).start()
            else:
                data_dic['error_msg'] = f"Unsupported Wave compression code {data_dic['compression_code']}"

        return data_dic

    #-------------------------------------------------------------------------------------------------
    def loop(self):
        # manage the playback by looping on the audio samples buffer to feed to the audio stream

        while self.data_buffer_pos < self.data_buffer_size and not self.playback_to_stop:

            if not self.playback_paused:
                self.stream.write(self.data_buffer[self.data_buffer_pos:self.data_buffer_pos + self.bytes_nb_per_loop])
                self.data_buffer_pos += self.bytes_nb_per_loop
            else:
                sd.sleep(100)

        # end of the buffer playback or playback has to be stopped
        self.playback_in_progress = False
        self.playback_paused = False
        self.playback_to_stop = False

        self.stream.close()
        self.stream = None

    #-------------------------------------------------------------------------------------------------
    def pause_resume(self):
        # if a playback is in progress, toggle its state between pause and resume

        if self.playback_in_progress:
            # ask to the loop fuction to pause/resume the playback
            self.playback_paused = not self.playback_paused


    #-------------------------------------------------------------------------------------------------
    def stop(self):
        # if a playback is in progress, stop it

        if self.playback_in_progress:
            # ask to the loop fuction to stop the playback
            self.playback_to_stop = True
            while self.stream != None: sd.sleep(100)

            self.playback_in_progress = False

    #-------------------------------------------------------------------------------------------------
    def wav_data_get(self, file_name, pitch_only=False):
        # return in a dictionary the metadata of the given .wav file (wave or wavpack format)
        # if pitch_only = True, recover only the MIDI note and pitch then exit immediately (for a fast processing)

        # the returned keys are :
        #   file_format : "wave" or "wavpack" or None if error
        #   error_msg   : message describing an error occured during the file processing, empty string if no error
        #   metadata_recovered : True if the metadata of the file have been recovered successfully
        #   compression_code : 1='Microsoft PCM', 3='Microsoft IEEE float', several other...
        #   nb_of_channels   : 1=mono, 2=stereo
        #   sampling_rate    : for example 44100 (Hz)
        #   bits_per_sample  : for example 16 (bits)
        #   nb_of_samples    : number of audio samples
        #   audio_data_size  : size in bytes of the sampled audio data
        #   audio_duration   : the duration in seconds (with two decimals) of the sampled data
        #   sampled_data     : bytes buffer containing the sampled audio data
        # keys present only if a sample chunk is defined in the file
        #   midi_note        : MIDI note of the sample, integer between 0 and 127
        #   midi_pitch_fract : pitch fraction to add to the MIDI note frequency to get the exact sample frequency, float between 0 and 100
        #   loops_nb                : number of defined loops
        #   loop<n>_id              : ID of the loop n
        #   loop<n>_type            : type of the loop n (0=normal forward looping, 1=alternating forward and backward, 2=backward looping)
        #   loop<n>_start_sample    : number of the starting sample of the loop n
        #   loop<n>_start_seconds   : seconds of the starting sample of the loop n (with two decimals)
        #   loop<n>_end_sample      : number of the ending sample of the loop n
        #   loop<n>_end_seconds     : seconds of the ending sample of the loop n (with two decimals)
        #   loop<n>_replay_times_nb : number of times the loop has to be played (0=infinite)
        # keys present only if a cue chunk is defined in the file
        #   cue_points_nb           : number of defined cue points
        #   cue<n>_id               : ID of the cue point n
        #   cue<n>_position         : 0 if there is no playlist chunk, else the sample at which the cue point should occur
        #   cue<n>_chunk_id         : chunk ID of the chunk containing the cue point (wave or slnt)
        #   cue<n>_chunk_start      : file position of the start of the chunk containing the cue point
        #                             (byte offset relative to the start of the data section of the wave list chunk 'wavl' if one is defined)
        #   cue<n>_block_start      : file position of the start of the block containing the position
        #                             (byte offset relative to the start of the data section of the wave list chunk 'wavl' if one is defined)
        #   cue<n>_sample_start     : sample offset of the cue point relative to the start of the block (bytes)
        # keys present only if a LIST chunk is defined in the file
        #   info                    : a dictionary containing as keys the info ID and as value the corresponding info text

        metadata_dic = {}
        metadata_dic['error_msg'] = ''
        metadata_dic['metadata_recovered'] = False
        metadata_dic['sampled_data'] = []

        if not os.path.isfile(file_name):
            # the provided file doesn't exist
            metadata_dic['error_msg'] = f'The file "{file_name}" does not exist.'
            return metadata_dic

        # open the given file
        file_obj = open(file_name, 'rb')

        file_format = None
        data_type = None        # can be : 'chunk' (Wav file), 'block' or 'sub_block' or 'sub_block_chunk' (WavPack file)
        chunk_data_size = 0     # Wav or WavPack file
        block_data_size = 0     # WavPack file
        sub_block_data_size = 0 # WavPack file

        while file_obj.read(1):
            # scan the file while the end of file is not reached and no error has occured
            file_obj.seek(-1, 1)   # move the file pointer one byte back to compensate the read(1) of the while instruction

            if file_format == None:
                # identification of the file format from the first 4 bytes of the file
                file_type_str = file_obj.read(4)
                file_obj.seek(-4, 1)  # rewind at the beginning of the file
                if file_type_str == b'wvpk':
                    file_format = 'wavpack'
                    data_type = 'block'
                    if LOG_wav_decode: print(f'WavPack file {file_name}')
                elif file_type_str == b'RIFF':
                    file_format = 'wave'
                    data_type = 'chunk'
                    if LOG_wav_decode: print(f'Wave file {file_name}')
                else:
                    metadata_dic['error_msg'] = f'Unsupported format in file {file_name}, Wave or WavPack format is expected'
                    if LOG_wav_decode: print(f'Unsupported format in file {file_name}')
                    file_obj.close()
                    return metadata_dic

                metadata_dic['file_format'] = file_format

            if data_type == 'block':
                # start of a WavPack block

                # read the data of the block header
                file_obj.read(4)      # skip the ID "wvpk"
                block_data_size = int.from_bytes(file_obj.read(4), 'little')   # size of the entire block minus 8 bytes
                version = int.from_bytes(file_obj.read(2), 'little')           # 0x402 to 0x410 are valid for decode
                block_index_u8 = int.from_bytes(file_obj.read(1), 'little')    # upper 8 bits  of 40-bit block index
                total_samples_u8 = int.from_bytes(file_obj.read(1), 'little')  # upper 8 bits  of 40-bit total samples
                total_samples_l32 = int.from_bytes(file_obj.read(4), 'little') # lower 32 bits of 40-bit total samples
                block_index_l32 = int.from_bytes(file_obj.read(4), 'little')   # lower 32 bits of 40-bit block index
                nb_of_samples_in_block = int.from_bytes(file_obj.read(4), 'little') # number of samples in this block, 0=non-audio block
                flags  = int.from_bytes(file_obj.read(4), 'little')            # flags for id and decoding
                file_obj.read(4)      # skip the CRC for actual decoded data
                block_data_size -= 24 # entire block size -8 bytes -24 bytes read in the block header

                block_index = (block_index_u8 << 32) + block_index_l32
                nb_of_samples = (total_samples_u8 << 32) + total_samples_l32
                if LOG_wav_decode: print(f"  block : version = 0x{version:03X}, size = {block_data_size+32}, data size = {block_data_size} bytes, first sample index = {block_index}, nb of samples in the block = {nb_of_samples_in_block}, total number of samples = {nb_of_samples}, flags = 0x{flags:08X}")

                # get metadata from flags of the first block
                if block_index == 0 and not pitch_only:
                    metadata_dic['nb_of_samples'] = nb_of_samples
                    metadata_dic['bits_per_sample'] = ((flags & 0b11) + 1) * 8

                    if ((flags >> 2) & 0b1) == 0:
                        metadata_dic['nb_of_channels'] = 2
                    else:
                        metadata_dic['nb_of_channels'] = 1

                    metadata_dic['sampling_rate'] = self.wavpack_sample_rates[(flags >> 23) & 0b1111]
                    metadata_dic['compression_code'] = (flags >> 3) & 0b1  # 0 = losslessaudio, 1 = hybrid mode
                    metadata_dic['audio_data_size'] = metadata_dic['nb_of_samples'] * metadata_dic['nb_of_channels'] * (metadata_dic['bits_per_sample'] // 8)

                    if LOG_wav_decode: print(f"  block : nb of channels = {metadata_dic['nb_of_channels']}, bits per sample = {metadata_dic['bits_per_sample']}, sampling rate = {metadata_dic['sampling_rate']}, compression code = {metadata_dic['compression_code']}")

                if block_data_size > 0:
                    # the block contains data, a sub-block is going to follow in the file
                    data_type = 'sub_block'
                else:
                    if LOG_wav_decode: print('  no data inside')

            if data_type == 'sub_block':
                # start of a WavPack metadata sub-block

                sub_block_id = int.from_bytes(file_obj.read(1), 'little')
                block_data_size -= 1
                sub_block_func_id = sub_block_id & 0x3f

                # read the size of the sub-block (in bytes)
                if sub_block_id & 0x80:
                    # it is a large block, its size is encoded on 3 bytes
                    sub_block_data_size = int.from_bytes(file_obj.read(3), 'little') * 2  # x2 to convert the size from words to bytes
                    block_data_size -= 3
                    large_block = True
                else:
                    sub_block_data_size = int.from_bytes(file_obj.read(1), 'little') * 2
                    block_data_size -= 1
                    large_block = False

                if LOG_wav_decode: print(f'    sub-block : ID = 0x{sub_block_id:X}, function ID = 0x{sub_block_func_id:X}, large block = {large_block}, data size = {sub_block_data_size} bytes')

                if sub_block_func_id in (0x21, 0x22): # 0x21 = ID_RIFF_HEADER, 0x22 = ID_RIFF_TRAILER
                    # RIFF chunks are present in this sub-block
                    data_type = 'sub_block_chunk'
                    if LOG_wav_decode: print('      RIFF chunks inside')

                if sub_block_data_size == 0:
                    if LOG_wav_decode: print('      no data inside')

            if data_type in ('chunk', 'sub_block_chunk'):
                # start of a Wave chunk (in a Wav or WavPack file)

                chunk_id = file_obj.read(4).decode('utf-8', 'ignore')  # string of 4 characters
                chunk_data_size = int.from_bytes(file_obj.read(4), 'little')

                chunk_read_data_size = 0

                if chunk_data_size % 2:
                    # the chunk size has an odd number of bytes, a word padding byte is present after it
                    # increment the chunk size by 1 to cover this padding byte
                    chunk_data_size += 1

                if chunk_id == 'RIFF':
                    if LOG_wav_decode: print(f'      chunk : [{chunk_id}], wave file size = {chunk_data_size + 8} bytes')
                else:
                    if LOG_wav_decode: print(f'      chunk : [{chunk_id}], size = {chunk_data_size} bytes')

                if chunk_id == 'RIFF':
                    # RIFF chunk descriptor
                    if file_obj.read(4) == b'WAVE':  # RIFF type ID
                        # the RIFF type ID is WAVE, it is a valid .wav file
                        if LOG_wav_decode: print('        RIFF type ID = "WAVE"')
                    else:
                        metadata_dic['error_msg'] = 'RIFF chunk has not the "WAVE" type ID, unsuported file format'
                        if LOG_wav_decode: print('        RIFF chunk has not the "WAVE" type ID, unsuported file format')
                        file_obj.close()
                        return metadata_dic

                    chunk_data_size = 4  # in the RIFF chunk the data size value is the size of the file - 8 bytes
                                         # there are only 4 bytes of data in this chunk (the RIFF type ID)
                    chunk_read_data_size += 4

                elif chunk_id == 'fmt ' and not pitch_only:
                    # format chunk
                    metadata_dic['compression_code'] = int.from_bytes(file_obj.read(2), 'little')
                    metadata_dic['nb_of_channels'] = int.from_bytes(file_obj.read(2), 'little')
                    metadata_dic['sampling_rate'] = int.from_bytes(file_obj.read(4), 'little')
                    file_obj.read(4) # skip the bytes per second
                    file_obj.read(2) # skip the block align
                    metadata_dic['bits_per_sample'] = int.from_bytes(file_obj.read(2), 'little')
                    if LOG_wav_decode: print(f"        compression code = {metadata_dic['compression_code']}, nb of channels = {metadata_dic['nb_of_channels']}, sampling rate = {metadata_dic['sampling_rate']}, bits per sample = {metadata_dic['bits_per_sample']}")

                    chunk_read_data_size += 16

                elif chunk_id == 'smpl':
                    # sample chunk
                    file_obj.read(4) # skip the manufacturer ID
                    file_obj.read(4) # skip the product ID
                    file_obj.read(4) # skip the sample period
                    metadata_dic['midi_note'] = int.from_bytes(file_obj.read(4), 'little')
                    metadata_dic['midi_pitch_fract'] = float(int.from_bytes(file_obj.read(4), 'little') * 100 / 0xFFFFFFFF)
                    if pitch_only:
                        # the MIDI note and pitch are recovered and only them are expected, exit the function
                        file_obj.close()
                        metadata_dic['metadata_recovered'] = True
                        return metadata_dic

                    file_obj.read(4) # skip the SMPTE format
                    file_obj.read(4) # skip the SMPTE offset
                    metadata_dic['loops_nb'] = loops_nb = int.from_bytes(file_obj.read(4), 'little')
                    file_obj.read(4) # skip the sampler data bytes number
                    chunk_read_data_size += 36

                    for l in range(1, loops_nb+1):
                        metadata_dic[f'loop{l}_id'] = int.from_bytes(file_obj.read(4), 'little')
                        metadata_dic[f'loop{l}_type'] = int.from_bytes(file_obj.read(4), 'little')
                        metadata_dic[f'loop{l}_start_sample'] = int.from_bytes(file_obj.read(4), 'little')
                        metadata_dic[f'loop{l}_start_seconds'] = int(metadata_dic[f'loop{l}_start_sample'] * 1000 / metadata_dic['sampling_rate']) / 1000
                        metadata_dic[f'loop{l}_end_sample'] = int.from_bytes(file_obj.read(4), 'little')
                        metadata_dic[f'loop{l}_end_seconds'] = int(metadata_dic[f'loop{l}_end_sample'] * 1000 / metadata_dic['sampling_rate']) / 1000
                        file_obj.read(4) # skip the loop fraction
                        metadata_dic[f'loop{l}_replay_times_nb'] = int.from_bytes(file_obj.read(4), 'little')
                        chunk_read_data_size += 24
                    if LOG_wav_decode: print(f"        midi note = {metadata_dic['midi_note']}, midi pitch = {metadata_dic['midi_pitch_fract']}, loops nb = {metadata_dic['loops_nb']}")

                elif chunk_id == 'cue ' and not pitch_only:
                    # cue chunk
                    metadata_dic['cue_points_nb'] = cue_points_nb = int.from_bytes(file_obj.read(4), 'little')
                    chunk_read_data_size += 4

                    for c in range(1, cue_points_nb+1):
                        metadata_dic[f'cue{c}_id'] = int.from_bytes(file_obj.read(4), 'little')
                        metadata_dic[f'cue{c}_position'] = int.from_bytes(file_obj.read(4), 'little')
                        metadata_dic[f'cue{c}_chunk_id'] = file_obj.read(4).decode('utf-8', 'ignore')  # string of 4 characters
                        metadata_dic[f'cue{c}_chunk_start'] = int.from_bytes(file_obj.read(4), 'little')
                        metadata_dic[f'cue{c}_block_start'] = int.from_bytes(file_obj.read(4), 'little')
                        metadata_dic[f'cue{c}_sample_start'] = int.from_bytes(file_obj.read(4), 'little')
                        chunk_read_data_size += 24
                    if LOG_wav_decode: print(f"        cue points nb = {metadata_dic['cue_points_nb']}")

                elif chunk_id == 'LIST' and not pitch_only:
                    # list chunk
                    list_type_id = file_obj.read(4).decode('utf-8', 'ignore')
                    chunk_read_data_size += 4

                    if list_type_id == 'INFO':
                        # get the data of the INFO type list
                        metadata_dic['info'] = {}
                        while chunk_read_data_size < chunk_data_size:  # loop until the end of the chunk
                            info_id = file_obj.read(4).decode('utf-8', 'ignore')
                            text_size = int.from_bytes(file_obj.read(4), 'little')
                            text_content = file_obj.read(text_size).decode('utf-8', 'ignore')
                            while text_content[-1:] == '\x00':  # remove the trailing 0x00 characters
                                text_content = text_content[:-1]
                            metadata_dic['info'][info_id] = text_content
                            chunk_read_data_size += 8 + text_size

                            if (text_size % 2) != 0:
                                # the text size is an odd value whereas text must be word aligned
                                # move the file reading position by 1 byte forward at the next word starting position
                                file_obj.read(1)
                                chunk_read_data_size += 1

                        if LOG_wav_decode: print(f"        INFO = {metadata_dic['info'].keys()}")
                    else:
                        if LOG_wav_decode: print('        none data recovered')

                elif chunk_id == 'data' and not pitch_only:
                    # data chunk
                    metadata_dic['audio_data_size'] = chunk_data_size    # size in bytes of the sampled audio data
                    metadata_dic['nb_of_samples'] = int(chunk_data_size / (metadata_dic['nb_of_channels'] * metadata_dic['bits_per_sample'] // 8))
                    if LOG_wav_decode: print(f"        nb of samples = {metadata_dic['nb_of_samples']}, audio data size = {metadata_dic['audio_data_size']}")
                    if data_type == 'chunk':
                        # get the buffer of raw sampled audio data in case of Wav file only
                        metadata_dic['sampled_data'] = file_obj.read(chunk_data_size)
                        chunk_read_data_size += chunk_data_size
                    else:  # data_type is 'sub_block_chunk'
                        # if WavPack file, there are no audio samples in the data chunk
                        chunk_data_size = 0

                else:
                    if LOG_wav_decode: print("        none data recovered")

                # move the file pointer at the end of the chunk if it is not already there
                if chunk_data_size - chunk_read_data_size > 0:
                    file_obj.seek(chunk_data_size - chunk_read_data_size, 1)
                    if LOG_wav_decode: print(f'        file pointer moved at the end of the chunk by {chunk_data_size - chunk_read_data_size} bytes')

                if data_type == 'sub_block_chunk':
                    # update the remaining size of data not read in the parents sub-block and block
                    block_data_size -= 8 + chunk_data_size  # 8 is the size of chunk ID and size fields at the start of the chunk
                    sub_block_data_size -= 8 + chunk_data_size

                    if sub_block_data_size <= 0:
                        # the end of the sub-block with RIFF chunks inside is reached
                        data_type = 'sub_block'

            if data_type == 'sub_block' and sub_block_data_size > 0:
                # sub-block with unread data inside
                # move the file pointer at the end of the sub-block
                file_obj.seek(sub_block_data_size, 1)
                if LOG_wav_decode: print(f'      {sub_block_data_size} bytes skipped')
                block_data_size -= sub_block_data_size
                sub_block_data_size = 0

            if data_type == 'sub_block' and block_data_size <= 0:
                # block end is reached
                data_type = 'block'

            if data_type == 'block' and block_data_size > 0:
                # block with unread data inside
                # move the file pointer at the end of the block
                file_obj.seek(block_data_size, 1)
                if LOG_wav_decode: print(f'  {block_data_size} bytes skipped')
                block_data_size = 0

        # close the given file
        file_obj.close()

        metadata_dic['audio_duration'] = 0
        if file_format != None and not pitch_only:
            if 'audio_data_size' not in metadata_dic.keys():
                # audio file without data chunk inside
                metadata_dic['error_msg'] = f'The file "{file_name}" has no audio samples inside.'
            else:
                # compute the duration of the audio samples in seconds (float with 2 decimals)
                metadata_dic['audio_duration'] = int(metadata_dic['audio_data_size'] * 1000 / (metadata_dic['sampling_rate'] * metadata_dic['nb_of_channels'] * metadata_dic['bits_per_sample'] / 8)) / 1000

        metadata_dic['metadata_recovered'] = True

        return metadata_dic

# create a global instance of the C_AUDIO_PLAYER class
audio_player = C_AUDIO_PLAYER()

#-------------------------------------------------------------------------------------------------
class C_ODF_MISC:
    # class containing miscellaneous functions to manage data of GO ODF objects

    def compass_get(self, object_uid, rank_compass_in_stop=False):
        # return in a tuple the first and last MIDI notes of the given object (must be Manual, Stop or Rank)
        # or return None in case a compass is not defined in this object or expected attributes are not defined correctly

        object_type = self.object_type_get(object_uid)
        object_dic = self.object_dic_get(object_uid)

        if object_type == 'Manual':

            manual_first_access_key_midi_note = myint(self.object_attr_value_get(object_dic, 'FirstAccessibleKeyMIDINoteNumber'))
            if manual_first_access_key_midi_note == None:
                logs.add(f'ERROR : The section {object_uid} has no FirstAccessibleKeyMIDINoteNumber value defined')
                return None

            manual_access_keys_nb = myint(self.object_attr_value_get(object_dic, 'NumberOfAccessibleKeys'))
            if manual_access_keys_nb == None:
                logs.add(f'ERROR : The section {object_uid} has no NumberOfAccessibleKeys value defined')
                return None

            if myint(self.object_attr_value_get(object_uid, 'FirstAccessibleKeyLogicalKeyNumber')) == None:
                logs.add(f'ERROR : The section {object_uid} has no NumberOfLogicalKeys value defined')
                return None

            if myint(self.object_attr_value_get(object_uid, 'NumberOfLogicalKeys')) == None:
                logs.add(f'ERROR : The section {object_uid} has no NumberOfLogicalKeys value defined')
                return None

            return (manual_first_access_key_midi_note, manual_first_access_key_midi_note + manual_access_keys_nb - 1)


        if object_type == 'Stop':

            manual_uid = self.object_parent_manual_get(object_uid)
            manual_first_access_key_midi_note = myint(self.object_attr_value_get(manual_uid, 'FirstAccessibleKeyMIDINoteNumber'))
            if manual_first_access_key_midi_note == None:
                logs.add(f'ERROR : The section {manual_uid} has no FirstAccessibleKeyMIDINoteNumber value defined')
                return None

            manual_first_access_key_logic_key_nb = myint(self.object_attr_value_get(manual_uid, 'FirstAccessibleKeyLogicalKeyNumber'))
            if manual_first_access_key_logic_key_nb == None:
                logs.add(f'ERROR : The section {manual_uid} has no FirstAccessibleKeyLogicalKeyNumber value defined')
                return None

            manual_first_logical_key_midi_note = manual_first_access_key_midi_note - manual_first_access_key_logic_key_nb + 1

            stop_ranks_nb = myint(self.object_attr_value_get(object_dic, 'NumberOfRanks'), 0)

            stop_first_access_pipe_logic_key_nb = myint(self.object_attr_value_get(object_dic, 'FirstAccessiblePipeLogicalKeyNumber'))
            if stop_first_access_pipe_logic_key_nb == None:
                logs.add(f'ERROR : The section {object_uid} has no attribute FirstAccessiblePipeLogicalKeyNumber defined')
                return None

            stop_first_access_pipe_midi_note = manual_first_logical_key_midi_note + stop_first_access_pipe_logic_key_nb - 1

            stop_access_pipes_nb = myint(self.object_attr_value_get(object_dic, 'NumberOfAccessiblePipes'))
            if stop_access_pipes_nb == None:
                logs.add(f'ERROR : The section {object_uid} has no attribute NumberOfAccessiblePipes defined')
                return None

            if stop_ranks_nb == 0:
                stop_first_access_pipe_logic_pipe_nb = myint(self.object_attr_value_get(object_uid, 'FirstAccessiblePipeLogicalPipeNumber'))
                if stop_first_access_pipe_logic_pipe_nb == None:
                    logs.add(f'ERROR : The section {object_uid} has no FirstAccessiblePipeLogicalPipeNumber value defined')
                    return None

                stop_logic_pipes_nb = myint(self.object_attr_value_get(object_dic, 'NumberOfLogicalPipes'))
                if stop_logic_pipes_nb == None:
                    logs.add(f'ERROR : The section {object_uid} has no attribute NumberOfLogicalPipes defined')
                    return None

            if rank_compass_in_stop and stop_ranks_nb == 0:
                # instead of returning the compass of the stop, do return the compass of the rank defined in the stop

                stop_first_logical_pipe_midi_note = stop_first_access_pipe_midi_note - stop_first_access_pipe_logic_pipe_nb + 1

                return (stop_first_logical_pipe_midi_note, stop_first_logical_pipe_midi_note + stop_logic_pipes_nb - 1)

            return (stop_first_access_pipe_midi_note, stop_first_access_pipe_midi_note + stop_access_pipes_nb - 1)


        if object_type == 'Rank':

            rank_midi_note_first = myint(self.object_attr_value_get(object_dic, 'FirstMidiNoteNumber'))
            if rank_midi_note_first == None:
                logs.add(f'ERROR : The section {object_uid} has no attribute FirstMidiNoteNumber defined')
                return None

            rank_pipes_nb = myint(self.object_attr_value_get(object_dic, 'NumberOfLogicalPipes'))
            if rank_pipes_nb == None:
                logs.add(f'ERROR : The section {object_uid} has no attribute NumberOfLogicalPipes defined')
                return None

            return (rank_midi_note_first, rank_midi_note_first + rank_pipes_nb - 1)

        logs.add(f"A section {object_type} has no compass attributes")
        return None

    #-------------------------------------------------------------------------------------------------
    def compass_extend(self, object_uid, midi_note_ext):
        # extends the compass of the given object (Manual or Stop or Rank) of the ODF up or down to the given MIDI note included
        # return in a tuple the new first and last MIDI notes of the manual
        # or return None if an error has occurred

        # check if the given object can be extended
        compass = self.compass_get(object_uid)
        if compass == None:
            # the object has not a compass which can be extended or there are errors in the object
            return None

        object_type = self.object_type_get(object_uid)
        midi_note_first, midi_note_last = compass
        logs.add('--------------------------------------------------')
        logs.add(f'Trying to extend {object_uid} from MIDI notes compass {midi_note_first}-{midi_note_last} up to MIDI note {midi_note_ext}')
        logs.add('')

        if object_type == 'Rank':
            return self.compass_extend_rank(object_uid, midi_note_ext)

        if object_type == 'Stop':
            return self.compass_extend_stop(object_uid, midi_note_ext)

        if object_type == 'Manual':
            return self.compass_extend_manual(object_uid, midi_note_ext)

        return None

    #-------------------------------------------------------------------------------------------------
    def compass_extend_manual(self, object_uid, midi_note_ext):
        # extends the compass of the Stops objects which are children of the given Manual object UID, up to the given MIDI note (included)
        # return in a tuple the new first and last MIDI notes of the manual
        # or return None in case an issue has occurred

        object_type = self.object_type_get(object_uid)
        object_dic = self.object_dic_get(object_uid)

        if object_type != 'Manual':
            logs.add('INTERNAL ERROR : a Manual section is expected in compass_extend_manual()')
            return None

        # get the initial compass and data of the Manual
        first_midi_note_init, last_midi_note_init = self.compass_get(object_uid)
        first_midi_note_ext = first_midi_note_init
        last_midi_note_ext = last_midi_note_init

        nb_logical_keys = myint(self.object_attr_value_get(object_dic, 'NumberOfLogicalKeys'))
        nb_access_keys = myint(self.object_attr_value_get(object_dic, 'NumberOfAccessibleKeys'))
        first_access_key_logic_key_nb = myint(self.object_attr_value_get(object_dic, 'FirstAccessibleKeyLogicalKeyNumber'))
        first_access_key_midi_note = myint(self.object_attr_value_get(object_dic, 'FirstAccessibleKeyMIDINoteNumber'))

        stops_nb = myint(self.object_attr_value_get(object_dic, 'NumberOfStops'))
        if stops_nb == None:
            logs.add(f'ERROR : {object_uid} has no NumberOfStops value defined')
            return None
        if stops_nb == 0:
            logs.add(f'{object_uid} has no children Stop sections defined')
            return None

        pipes_stop_extended = False

        # extend each child stop of the given Manual object, if it is used by the last note of the manual
        for stop_idx in range(1, stops_nb + 1):

            stop_attr_id = 'Stop' + str(stop_idx).zfill(3)
            # get the ID and UID of the stop referenced in the current stop index
            stop_id = myint(self.object_attr_value_get(object_dic, stop_attr_id))
            if stop_id == None:
                logs.add(f'ERROR : the attribute {stop_attr_id} is not defined in {object_uid}')
                return None
            stop_uid = 'Stop' + str(stop_id).zfill(3)
            if self.object_dic_get(stop_uid) == None:
                logs.add(f'ERROR : the stop {stop_uid} referenced in {object_uid} as {stop_attr_id} does not exist')
                return None

            # get the initial compass of the current stop
            compass = self.compass_get(stop_uid)
            if compass == None:
                return None
            stop_first_midi_note_init, stop_last_midi_note_init = compass

            # extend the current stop
            if myint(self.object_attr_value_get(stop_uid, 'NumberOfAccessiblePipes')) == 1:
                compass = None
                logs.add(f'{stop_uid} is not extended as it has only one accessible pipe')
            elif stop_last_midi_note_init < last_midi_note_init:
                # the stop is not used by the last note of the manual
                compass = None
                logs.add(f'{stop_uid} does not have to be extended as it is not played by the last note of {object_uid}')
            elif mystr(self.object_attr_value_get(stop_uid, 'AcceptsRetuning')) == 'N' and pipes_stop_extended:
                # the current stop cannot be retuned, it should be a stop containing noises
                # extend it until the last extended note of the manual if pipes stop has been extended before, in case it is a stop with keys noises
                compass = self.compass_extend_stop(stop_uid, last_midi_note_ext)
            else:
                compass = self.compass_extend_stop(stop_uid, midi_note_ext)
                pipes_stop_extended = True

            if compass != None:
                # the stop has been extended
                stop_first_midi_note_ext, stop_last_midi_note_ext = compass
                stop_last_midi_note_ext = min(stop_last_midi_note_ext, midi_note_ext)  # if the stop goes beyond the extension MIDI note, ignore the beyong compass

                # update the last MIDI note of the manual based on the extension done in the current stop
                last_midi_note_ext = max(last_midi_note_ext, stop_last_midi_note_ext)

            logs.add('')  # add a blank line in the logs window between each stop

        # update the number of accessible keys
        nb_access_keys_ext = last_midi_note_ext - first_access_key_midi_note + 1
        self.object_attr_value_set(object_uid, 'NumberOfAccessibleKeys', nb_access_keys_ext)

        # update the number of logical keys
        if first_access_key_logic_key_nb + nb_access_keys_ext - 1 > nb_logical_keys:
            nb_logical_keys_ext = first_access_key_logic_key_nb + nb_access_keys_ext - 1
            self.object_attr_value_set(object_uid, 'NumberOfLogicalKeys', nb_logical_keys_ext)

        # add the DisplayKeys attribute if it is not yet defined, to set it at the initial compass, so that the number of displayed keys is unchanged
        # to be placed in the child PanelElement (Type=Manual) object of the Manual if it is defined, else in the Manual object
        panel_elem_children_list = self.object_kinship_list_get(object_uid, TO_CHILD, 'PanelElement')
        if len(panel_elem_children_list) > 0:
            # the Manual has a child PanelElement (which is supposed to have the type Manual)
            manual_panel_elem_uid = panel_elem_children_list[0]
            if self.object_attr_value_get(manual_panel_elem_uid, 'DisplayKeys') == None:
                # the PanelElement object has not yet the attribute DisplayKeys
                self.object_attr_value_set(manual_panel_elem_uid, 'DisplayKeys', last_midi_note_init - first_midi_note_init + 1)
        else:
            if self.object_attr_value_get(object_uid, 'DisplayKeys') == None:
                # the Manual object has not yet the attribute DisplayKeys
                self.object_attr_value_set(object_uid, 'DisplayKeys', last_midi_note_init - first_midi_note_init + 1)

        if nb_access_keys_ext > nb_access_keys:
            logs.add(f'{object_uid} MIDI notes compass extended from {first_midi_note_init}-{last_midi_note_init} to {first_midi_note_ext}-{last_midi_note_ext}')
        else:
            logs.add(f'{object_uid} compass not extended')

        return first_midi_note_ext, last_midi_note_ext

    #-------------------------------------------------------------------------------------------------
    def compass_extend_stop(self, object_uid, midi_note_ext):
        # extends the compass of the Rank objects which are children of the given Stop object UID, up to the given MIDI note (included)
        # return in a tuple the new first and last MIDI notes of the stop
        # or return None in case an issue has occurred

        object_type = self.object_type_get(object_uid)
        object_dic = self.object_dic_get(object_uid)

        if object_type != 'Stop':
            logs.add('INTERNAL ERROR : a Stop section is expected in compass_extend_stop()')
            return None

        # get the initial compass of the Stop (accessible pipes compass)
        compass = self.compass_get(object_uid)
        if compass == None:
            return None

        first_midi_note_init, last_midi_note_init = compass

        if midi_note_ext <= last_midi_note_init:
            logs.add(f'{object_uid} has the MIDI notes compass {first_midi_note_init}-{last_midi_note_init} which covers the MIDI note {midi_note_ext}, it does not need to be extended')
            return first_midi_note_init, last_midi_note_init

        if myint(self.object_attr_value_get(object_uid, 'NumberOfAccessiblePipes')) == 1:
            logs.add(f'{object_uid} is not extended as it has only one accessible pipe')
            return first_midi_note_init, last_midi_note_init

        last_midi_note_ext = last_midi_note_init  # this value will increase based on the extension actually done in each rank used by the stop

        ranks_nb = myint(self.object_attr_value_get(object_uid, 'NumberOfRanks'), 0)

        if ranks_nb == 0:
            # one rank definition is included in the Stop object

            # extend the rank up to the given MIDI note extension
            compass = self.compass_extend_rank(object_uid, midi_note_ext)
            if compass == None:
                # an error has occured
                return None
            rank_first_midi_note_ext, rank_last_midi_note_ext = compass

            # update the number of accessible pipes of the stop
            rank_last_used_midi_note_ext = min(rank_last_midi_note_ext, midi_note_ext) # if the rank goes beyond the MIDI note extension, ignore the beyong compass
            nb_access_pipes = rank_last_used_midi_note_ext - first_midi_note_init + 1
            self.object_attr_value_set(object_uid, 'NumberOfAccessiblePipes', nb_access_pipes)

            last_midi_note_ext = rank_last_used_midi_note_ext

        else:
            # it is a stop having children ranks, extend each child rank if it is used by the last note of the stop

            for rank_idx in range(1, ranks_nb + 1):
                # scan the children ranks

                rank_attr_id = 'Rank' + str(rank_idx).zfill(3)
                # get the ID and UID of the rank referenced in the current rank index
                rank_id = myint(self.object_attr_value_get(object_dic, rank_attr_id))
                if rank_id == None:
                    logs.add(f'ERROR : the attribute {rank_attr_id} is not defined in {object_uid}')
                    return None
                rank_uid = 'Rank' + str(rank_id).zfill(3)
                if self.object_dic_get(rank_uid) == None:
                    logs.add(f'ERROR : the rank {rank_uid} referenced in {object_uid} as {rank_attr_id} does not exist')
                    return None

                # get the initial compass of the current rank
                compass = self.compass_get(rank_uid)
                if compass == None:
                    return None
                rank_first_midi_note_init, rank_last_midi_note_init = compass

                # recover the MIDI notes compass used by the Stop in the current rank
                rank_first_used_pipe_nb = myint(self.object_attr_value_get(object_dic, rank_attr_id + 'FirstPipeNumber'), 1)
                rank_used_pipes_count = myint(self.object_attr_value_get(object_dic, rank_attr_id + 'PipeCount'), rank_last_midi_note_init - rank_first_midi_note_init + 1 - (rank_first_used_pipe_nb - 1))
                rank_first_used_midi_note_init = rank_first_midi_note_init + (rank_first_used_pipe_nb - 1)
                rank_last_used_midi_note_init = rank_first_used_midi_note_init + rank_used_pipes_count - 1

                logs.add(f'{object_uid} uses in {rank_uid} the MIDI notes compass {rank_first_used_midi_note_init}-{rank_last_used_midi_note_init}')

                # recover the MIDI note shift from manual keys to rank pipes
                manual_first_access_key_nb = myint(self.object_attr_value_get(object_dic, rank_attr_id + 'FirstAccessibleKeyNumber'), 1)
                midi_note_manual_to_rank_shift = rank_first_used_midi_note_init - (first_midi_note_init + manual_first_access_key_nb - 1)
                if midi_note_manual_to_rank_shift != 0:
                    logs.add(f'                  from manual keys MIDI notes compass {rank_first_used_midi_note_init - midi_note_manual_to_rank_shift}-{rank_last_used_midi_note_init - midi_note_manual_to_rank_shift}')

                if last_midi_note_init + midi_note_manual_to_rank_shift <= rank_last_used_midi_note_init:
                    # the last note of the stop if using the current rank, so extend it
                    compass = self.compass_extend_rank(rank_uid, midi_note_ext + midi_note_manual_to_rank_shift)
                    if compass != None:
                        rank_first_midi_note_ext, rank_last_midi_note_ext = compass
                        rank_last_used_midi_note_ext = min(rank_last_midi_note_ext, midi_note_ext + midi_note_manual_to_rank_shift)  # if the rank goes beyond the extension MIDI note, ignore the beyong compass

                        # update the number of pipes used by the stop in the current rank
                        if self.object_attr_value_get(object_dic, rank_attr_id + 'PipeCount') != None:
                            # the attribute Rank999PipeCount is defined, update it
                            rank_pipe_count_ext = rank_last_used_midi_note_ext - rank_first_used_midi_note_init + 1
                            self.object_attr_value_set(object_dic, rank_attr_id + 'PipeCount', rank_pipe_count_ext)

                        if mystr(self.object_attr_value_get(rank_uid, 'AcceptsRetuning'), 'Y') == 'Y':
                            # update the last MIDI note of the stop based on the extension done in the current rank
                            # only if the rank can be retuned
                            # this is to avoid to take into the extension of the ranks which can be extended up to the required MIDI note without pitch tuning limitation
                            last_midi_note_ext = max(last_midi_note_ext, rank_last_used_midi_note_ext - midi_note_manual_to_rank_shift)

                else:
                    logs.add(f'{rank_uid} does not have to be extended as it is not played by the last note of {object_uid}')

            # update the number of pipes used in the stop, adding to it the number of added MIDI notes in the ranks
            nb_access_pipes = myint(self.object_attr_value_get(object_uid, 'NumberOfAccessiblePipes')) + last_midi_note_ext - last_midi_note_init
            self.object_attr_value_set(object_uid, 'NumberOfAccessiblePipes', nb_access_pipes)

            if last_midi_note_ext > last_midi_note_init:
                logs.add(f'{object_uid} MIDI notes compass extended from {first_midi_note_init}-{last_midi_note_init} to {first_midi_note_init}-{last_midi_note_ext}')
            else:
                logs.add(f'{object_uid} MIDI notes compass not extended')

        return first_midi_note_init, last_midi_note_ext

    #-------------------------------------------------------------------------------------------------
    def compass_extend_rank(self, object_uid, midi_note_ext):
        # extends the compass of the given object UID (rank or stop with rank data inside) of the GO ODF, up/down to the given MIDI note (included)
        # borrowing existing pipes of the rank with one octave of interval
        # the extension can be done below or above the existing compass
        # return in a tuple the new first and last MIDI notes of the rank
        # or return None in case an issue has occurred

        object_type = self.object_type_get(object_uid)
        object_dic = self.object_dic_get(object_uid)

        # get the initial MIDI notes compass of the given Rank or Stop
        if object_type not in ('Rank', 'Stop'):
            logs.add('INTERNAL ERROR : a Rank or Stop section is expected in compass_extend_rank()')
            return None

        # get the compass of the given Rank or the rank which is inside the given Stop
        compass = self.compass_get(object_uid, object_type == 'Stop')
        if compass == None:
            # there is an error in the objects
            return None

        first_midi_note_init, last_midi_note_init = compass

        if last_midi_note_init - first_midi_note_init < 12:
            logs.add(f'{object_uid} is not extended as it has less than 12 accessible pipes')
            return first_midi_note_init, last_midi_note_init

        rank_accepts_retuning = mystr(self.object_attr_value_get(object_dic, 'AcceptsRetuning'), 'Y')

        # define the extended MIDI notes compass of the given rank
        if midi_note_ext < first_midi_note_init:
            # extension below the initial rank compass
            first_midi_note_ext = midi_note_ext
            last_midi_note_ext = last_midi_note_init
        elif midi_note_ext > last_midi_note_init:
            # extension above the initial rank compass
            first_midi_note_ext = first_midi_note_init
            last_midi_note_ext = midi_note_ext
        else:
            # no extension to do, the given MIDI note is inside the initial rank compass
            logs.add(f'{object_uid} does not need to be extended, the MIDI note {midi_note_ext} is inside its MIDI notes compass {first_midi_note_init}-{last_midi_note_init}')
            return first_midi_note_init, last_midi_note_init

        # build a dictionary having as keys all MIDI notes of the extended rank
        # and for each MIDI note a tuple value with : the pipe number of the initial rank to use to play this MIDI note
        #                                             the pitch tuning in cents to apply to this pipe to play the MIDI note
        #                                             the gain to apply to the pipe (+5dB to apply if negative pitch tuning, -5dB if positive pitch tuning)
        # or None if none pipe can be mapped for the MIDI note
        midi_pipe_mapping_dic = {}
        for midi_note_nb in range(first_midi_note_ext, last_midi_note_ext + 1):
            # scan the MIDI notes of the extended compass

            # determine if an existing pipe has to be changed to play the current MIDI note
            if midi_note_nb < first_midi_note_init:
                # the current MIDI note is below the first MIDI note of the initial rank : need to apply a -1 octave pitch tuning
                change_factor = -1
            elif midi_note_nb > last_midi_note_init:
                # the current MIDI note is above the last MIDI note of the initial rank : need to apply a +1 octave pitch tuning
                change_factor = 1
            else:
                # the current MIDI note is within the initial MIDI notes range : no pitch tuning to apply
                change_factor = 0

            # determine which pipe of the rank has to be used to play the current MIDI note
            while 1:
                used_midi_note = midi_note_nb - 12 * change_factor

                if used_midi_note in range(first_midi_note_init, last_midi_note_init + 1):
                    # the note to use is inside the initial compass of the rank, take it
                    break

                if rank_accepts_retuning == 'Y' and abs(change_factor) == 1:
                    # the note to use is outside the initial compass of the rank with a pitch tuning of 1 x 1200 cents and the rank can be retuned
                    # the retuning cannot be more than 1 x 1200 cents, so none note can be used
                    used_midi_note = None
                    break

                if change_factor == 5:
                    # stop the factor increase loop at 5 x 1200 cents, none note can be used
                    used_midi_note = None
                    break

                # try to use a note with one octave of distance more
                if change_factor > 0:
                    change_factor += 1
                else:
                    change_factor -= 1

            # do the mapping between the current MIDI note and one existing pipe of the rank if possible
            if used_midi_note != None:
                # the note to use is inside the initial compass of the rank
                # determine the associated pipe
                used_pipe_nb = used_midi_note - first_midi_note_init + 1
                used_pipe_id = 'Pipe' + str(used_pipe_nb).zfill(3)

                # check if the pipe can be used, and if yes map it with the current MIDI note
                if mystr(self.object_attr_value_get(object_dic, used_pipe_id)).startswith('REF'):
                    # the pipe to use is borrowing another pipe using the REF:aa:bb:cc syntax
                    if change_factor != 0:
                        # the pipe to use must be retuned but it cannot because it is using the REF:aa:bb:cc syntax
                        midi_pipe_mapping_dic[midi_note_nb] = None
                        logs.add(f'{object_uid} : {used_pipe_id} (MIDI {used_midi_note}) cannot be used to play the MIDI note {midi_note_nb} as it is a borrowed pipe')
                    else:
                        midi_pipe_mapping_dic[midi_note_nb] = (used_pipe_nb, 0, 0)

                elif mystr(self.object_attr_value_get(object_dic, used_pipe_id + 'AcceptsRetuning'), rank_accepts_retuning) == 'Y':
                    # the pipe to use can be retuned, apply the change factor to its existing pitch tuning and gain values
                    pitch_tuning = 1200 * change_factor + myfloat(self.object_attr_value_get(object_dic, used_pipe_id + 'PitchTuning'), 0.0)
                    pipe_gain = max(min(-5.0 * change_factor + myfloat(self.object_attr_value_get(object_dic, used_pipe_id + 'Gain'), 0.0), 40.0), -120.0)

                    if abs(pitch_tuning) > 1800:
                        midi_pipe_mapping_dic[midi_note_nb] = None
                        logs.add(f'{object_uid} : {used_pipe_id} (MIDI {used_midi_note}) cannot be used to play the MIDI note {midi_note_nb}, a pitch tuning of {pitch_tuning} cents is necessary')
                    else:
                        midi_pipe_mapping_dic[midi_note_nb] = (used_pipe_nb, pitch_tuning, pipe_gain)

                else:
                    # the pipe to use cannot be retuned, let unchanged its existing pitch tuning and gain
                    pitch_tuning = myfloat(self.object_attr_value_get(object_dic, used_pipe_id + 'PitchTuning'), 0)
                    pipe_gain = myfloat(self.object_attr_value_get(object_dic, used_pipe_id + 'Gain'), 0)
                    midi_pipe_mapping_dic[midi_note_nb] = (used_pipe_nb, pitch_tuning, pipe_gain)

            else:
                # none pipe can be used
                midi_pipe_mapping_dic[midi_note_nb] = None
                logs.add(f'{object_uid} : none pipe of the rank can be used to play the MIDI note {midi_note_nb} with a pitch tuning of {1200 * change_factor} cents')

        # check if consecutive MIDI notes at the beginning or the end of the extended compass have no mapped pipe in order to remove them
        for midi_note_nb in list(midi_pipe_mapping_dic.keys()):
            if midi_pipe_mapping_dic[midi_note_nb] == None:
                midi_pipe_mapping_dic.pop(midi_note_nb)
            else:
                # stop the loop at the first mapped pipe
                break
        for midi_note_nb in reversed(list(midi_pipe_mapping_dic.keys())):
            if midi_pipe_mapping_dic[midi_note_nb] == None:
                midi_pipe_mapping_dic.pop(midi_note_nb)
            else:
                break
        # update the MIDI notes extended compass in case some dictionary entries have been removed above
        first_midi_note_ext = 999
        last_midi_note_ext = 0
        for midi_note_nb in midi_pipe_mapping_dic.keys():
            first_midi_note_ext = min(midi_note_nb, first_midi_note_ext)
            last_midi_note_ext  = max(midi_note_nb, last_midi_note_ext)

        if first_midi_note_ext == first_midi_note_init and last_midi_note_ext == last_midi_note_init:
            # no extension can be done finally
            logs.add(f'{object_uid} cannot be extended as none existing pipe can be reused')
            return first_midi_note_init, last_midi_note_init

        # create an object to put in it the extended rank/stop copied from the given rank/stop
        new_object_dic = self.object_new()
        new_object_dic['names'] = object_dic['names']
        new_object_dic['parents'] = object_dic['parents']
        new_object_dic['children'] = object_dic['children']
        # move in the extended rank/stop all the attributes of the current one except the pipe attributes
        for line in object_dic['lines']:
            if line[:4] != 'Pipe':
                new_object_dic['lines'].append(line)

        # build the pipe attributes of the extended rank/stop
        for (midi_note_nb, mapping_data) in midi_pipe_mapping_dic.items():
            # scan the MIDI notes of the mapping dictionary

            # define the pipe nb and ID that the current MIDI note must have in the new compass
            pipe_nb_new = midi_note_nb - first_midi_note_ext + 1
            pipe_id_new = 'Pipe' + str(pipe_nb_new).zfill(3)

            if mapping_data != None:
                # a pipe of the initial rank can be used to play the current MIDI note
                (pipe_nb_init, pitch_tuning, pipe_gain) = mapping_data

                pipe_id_init = 'Pipe' + str(pipe_nb_init).zfill(3)
                # recover all the attributes of this pipe
                pipe_lines_list = self.object_lines_search(object_uid, pipe_id_init)

                # add or update the Gain attribute in the pipe lines list
                if pipe_gain != 0:
                    gain_line_found = False
                    pipe_id_gain_init = pipe_id_init + 'Gain'
                    for i, line in enumerate(pipe_lines_list):
                        if line.startswith(pipe_id_gain_init):
                            # the pipe has the Gain attribute defined, update it
                            (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                            pipe_lines_list[i] = self.object_line_join(attr_name, myfloat2str(pipe_gain), comment)
                            gain_line_found = True
                            break

                    if not gain_line_found:
                        # the pipe has not already the Gain attribute defined, add it in first position
                        pipe_lines_list.insert(0, pipe_id_gain_init + '=' + myfloat2str(pipe_gain))

                # add or update the PitchTuning attribute in the pipe lines list if a pitch tuning has to be done
                if pitch_tuning != 0:
                    pitch_line_found = False
                    for i, line in enumerate(pipe_lines_list):
                        if line.startswith(pipe_id_init + 'PitchTuning='):
                            # the pipe has already the PitchTuning attribute defined, update it
                            (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                            pipe_lines_list[i] = self.object_line_join(attr_name, myfloat2str(pitch_tuning), comment)
                            pitch_line_found = True
                            break

                    if not pitch_line_found:
                        # the pipe has not already the PitchTuning attribute defined, add it in first position
                        pipe_lines_list.insert(0, pipe_id_init + 'PitchTuning=' + str(pitch_tuning))

                # add all the attributes of the pipe to the new object, renaming the pipe ID if it is changed
                for line in pipe_lines_list:
                    if pipe_nb_new != pipe_nb_init:
                        line = line.replace(pipe_id_init, pipe_id_new)
                    new_object_dic['lines'].append(line)

            else:
                # a pipe of the initial rank cannot be used to play the current MIDI note, so set a dummy pipe
                new_object_dic['lines'].append(pipe_id_new + '=DUMMY')

        # delete in the ODF the current rank/stop
        self.odf_data_dic.pop(object_uid)

        # add in the ODF the extended rank/stop
        self.odf_data_dic[object_uid] = new_object_dic

        # update the compass related attributes of the Rank or Stop (with rank attributes inside)
        self.object_attr_value_set(new_object_dic, 'NumberOfLogicalPipes', last_midi_note_ext - first_midi_note_ext + 1)

        if object_type == 'Rank':
            self.object_attr_value_set(new_object_dic, 'FirstMidiNoteNumber', first_midi_note_ext)
        else:  # object_type == 'Stop'
            if myint(self.object_attr_value_get(new_object_dic, 'FirstMidiNoteNumber')) != None:
                # the attribute FirstMidiNoteNumber is defined in the Stop (it is not required in a Stop section), so update it
                self.object_attr_value_set(new_object_dic, 'FirstMidiNoteNumber', first_midi_note_ext)

        if last_midi_note_ext > last_midi_note_init:
            logs.add(f'{object_uid} MIDI notes compass extended from {first_midi_note_init}-{last_midi_note_init} to {first_midi_note_ext}-{last_midi_note_ext}')
        else:
            logs.add(f'{object_uid} compass not extended')

        return (first_midi_note_ext, last_midi_note_ext)


#-------------------------------------------------------------------------------------------------
class C_ODF_DATA_CHECK:
    # class to check the data (syntax, consistency) contained in the GO ODF data

    check_files_names = True    # flag indicating if files names have to be checked or not during the ODF data check
    checked_attr_nb = 0         # number of attributes checked during the checking operation

    #-------------------------------------------------------------------------------------------------
    def check_odf_data(self, progress_status_update_fct, files_names_to_check=True):
        # check the consistency of the data which are present in ODF data of the C_ODF_DATA class

        self.check_files_names = files_names_to_check
        self.checked_attr_nb = 0

        logs.add("ODF data check report :")

        # check the presence of the Organ object
        if 'Organ' not in self.odf_data_dic.keys():
            logs.add("ERROR the Organ section is not defined")

        for object_uid, object_dic in sorted(self.odf_data_dic.items()):
            # scan the objects of the ODF data dictionary

            # recover a copy of the lines of the current object
            object_lines_list = list(object_dic['lines'])

            # update in the GUI the name of the checked object
            progress_status_update_fct(f'Checking {object_uid}...')

            if len(object_lines_list) > 0:
                # lines have been recovered for the current object

                # sort the lines list to make faster the search which is done in check_attribute_value
                object_lines_list.sort()

                # remove the first line while it is empty (after the sorting the empty lines are all in first positions)
                while len(object_lines_list) > 0 and len(object_lines_list[0]) == 0:
                    object_lines_list.pop(0)

                # check if the attributes are all uniques in the object
                self.check_attributes_unicity(object_uid, object_lines_list)

                # check the attributes and values of the object by type
                object_type = self.object_type_get(object_uid)
                if object_type == 'Header':
                    self.check_object_Header(object_uid, object_lines_list)
                elif object_type == 'Organ':
                    self.check_object_Organ(object_uid, object_lines_list)
                elif object_type == 'Coupler':
                    self.check_object_Coupler(object_uid, object_lines_list)
                elif object_type == 'Divisional':
                    self.check_object_Divisional(object_uid, object_lines_list)
                elif object_type == 'DivisionalCoupler':
                    self.check_object_DivisionalCoupler(object_uid, object_lines_list)
                elif object_type == 'Enclosure':
                    self.check_object_Enclosure(object_uid, object_lines_list)
                elif object_type == 'General':
                    self.check_object_General(object_uid, object_lines_list)
                elif object_type == 'Image':
                    self.check_object_Image(object_uid, object_lines_list)
                elif object_type == 'Label':
                    self.check_object_Label(object_uid, object_lines_list)
                elif object_type == 'Manual':
                    self.check_object_Manual(object_uid, object_lines_list)
                elif object_type == 'Panel':
                    self.check_object_Panel(object_uid, object_lines_list)
                elif object_type == 'PanelElement':
                    self.check_object_PanelElement(object_uid, object_lines_list)
                elif object_type[:5] == 'Panel': # Panel999Coupler999, Panel999Divisional999, Panel999Image999, ...
                    self.check_object_PanelOther(object_uid, object_lines_list)
                elif object_type == 'Rank':
                    self.check_object_Rank(object_uid, object_lines_list)
                elif object_type == 'ReversiblePiston':
                    self.check_object_ReversiblePiston(object_uid, object_lines_list)
                elif object_type == 'SetterElement':
                    self.check_object_SetterElement(object_uid, object_lines_list)
                elif object_type == 'Stop':
                    self.check_object_Stop(object_uid, object_lines_list)
                elif object_type == 'Switch':
                    self.check_object_Switch(object_uid, object_lines_list)
                elif object_type == 'Tremulant':
                    self.check_object_Tremulant(object_uid, object_lines_list)
                elif object_type == 'WindchestGroup':
                    self.check_object_WindchestGroup(object_uid, object_lines_list)
                else:
                    # the object type is unknown
                    logs.add(f"WARNING the section {object_uid} has an unknown type")
                    # empty the lines list of the object which is not recognized, to not display later in the log its attributes which have not been checked
                    object_lines_list = []

                # check the lines not checked by the function check_attribute_value() (which has removed in object_lines_list the checked lines)
                for line in object_lines_list:
                    (error_msg, attr_name, attr_value, comment) = self.check_object_line(line, True)
                    if error_msg != None:
                        logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')

                    if attr_name not in (None, 'uid'):
                        # the current line is an attribute line
                        self.checked_attr_nb += 1
                        logs.add(f"WARNING in {object_uid} : the attribute {attr_name} is not expected in this section or is misspelled")

        # display in the log the number of checked attributes
        logs.add(f"{self.checked_attr_nb:,} attributes checked")

        # check the kind of panel format (new or old)
        self.check_panel_format()

        # display in the log if none error has been detected
        if logs.nb_get() <= 3:  # there are 3 log lines when there is no error : check start message + detected panel format + number of checked attributes
            logs.add("None error found, can be loaded in GrandOrgue for a final check")

    #-------------------------------------------------------------------------------------------------
    def check_panel_format(self):
        # check which is the panel format used in the ODF (new or old) and update the flag

        value = self.object_attr_value_get('Panel000', 'NumberOfGUIElements')
        self.new_panel_format_bool = (value != None and value.isdigit() and int(value) >= 0)

        if self.new_panel_format_bool:
            logs.add('New panel format')
        else:
            logs.add('Old panel format')

    #-------------------------------------------------------------------------------------------------
    def check_object_uid(self, object_uid):
        # return an error message if an issue is detected in the given object UID, else None

        error_msg = None

        object_type = self.object_type_get(object_uid)

        if not object_uid.isalnum():
            error_msg = 'a section name can contain only alphanumeric characters'
        elif object_type not in self.go_objects_children_dic.keys():
            error_msg = f'{object_type} is an unknown section type'
        elif object_type not in ('Organ', 'Header'):
            if not object_uid[-3:].isdigit():
                error_msg = f'three digits are expected at the end of "{object_uid}"'
            elif int(object_uid[-3:]) == 0 and not object_type in ('Panel', 'Manual'):
                error_msg = f"{object_uid} cannot have the index 000"
            elif object_uid[:5] == 'Panel' and len(object_uid) > 8 and not object_uid[5:8].isdigit():
                # Panel999xxxxx999 object
                error_msg = f'three digits are expected after "Panel" in "{object_uid}"'

        return error_msg

    #-------------------------------------------------------------------------------------------------
    def check_object_line(self, line, do_check_chars):
        # check the syntax of the given object line and extract from it the attribute name + attribute value + comment
        # return a tuple containing : (error message, attribute name, attribute value, comment)
        # attribute name = 'uid' if the given line contains an object UID between brackets, the UID is in the attribute value
        # error message = an error description message in case a syntax error has been detected in the given line, or None if no error found

        error_msg = attr_name = attr_value = comment = None

        if line not in (None, ''): # not an empty line
            if line[0] == "[":
                # line with an object UID inside normally
                pos = line.find(']', 1)
                if pos == -1:  # object ID without closing bracket
                    error_msg = 'character "]" is missing to define an object ID'
                    comment = line
                elif pos == 1: # object ID with no string between the brackets
                    error_msg = 'no object identifier defined between the brackets'
                    comment = line
                else:
                    attr_name = 'uid'
                    attr_value = line[1:pos]
                    # check the coherency of the UID
                    error_msg = self.check_object_uid(attr_value)

                    if error_msg == None and len(line) > pos + 1:
                        # there are characters after the ]
                        comment = line[pos+1:]
                        if comment.lstrip()[0] != ';':
                            error_msg = 'only text beginning by ; is allowed after the ] character'

            elif line[0] == ";":
                # comment line
                comment = line

            elif line[0] == "=":
                # the line starts by an equal character
                error_msg = 'the character "=" cannot start a line'
                comment = line

            else:
                # line containing an attribute definition normally
                # recover the string parts on both sides of the = character
                line_parts_list = line.split('=')
                if len(line_parts_list) == 1:
                    # there is none equal character present in the line
                    error_msg = 'missing character ";" (if comment) or "=" (if attribute)'
                    comment = line
                else:
                    attr_name = line_parts_list[0]
                    if do_check_chars:
                        for char in attr_name:
                            if char not in ALLOWED_CHARS_4_FIELDS:
                                # the attribute name has a forbiden character
                                error_msg = f'the attribute "{attr_name}" can contain only alphanumeric or "_" characters'
                                break

                    # recover the string parts on both sides of the ; character at the right of the = character
                    line_parts_list = line_parts_list[1].split(';')
                    attr_value = line_parts_list[0].rstrip()
                    if len(line_parts_list) > 1:
                        comment = ';' + line_parts_list[1]

        return (error_msg, attr_name, attr_value, comment)

    #-------------------------------------------------------------------------------------------------
    def check_object_Header(self, object_uid, lines_list):
        # check the data of the Header object which the lines are in the given lines list
        # the lines must be either starting by a semi-colon or empty

        for line in lines_list:
            if len(line) > 0 and line[0] != ';':
                logs.add(f'ERROR in {object_uid} : this line must start with a semi-colon "{line}"')

    #-------------------------------------------------------------------------------------------------
    def check_object_Organ(self, object_uid, lines_list):
        # check the data of the Organ object which the lines are in the given lines list

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'ChurchName', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'ChurchAddress', ATTR_TYPE_STRING, True)

        value = self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)
        if value == "Y" and not 'Manual000' in self.odf_data_dic:
            logs.add(f"ERROR in {object_uid} : HasPedals=Y but no Manual000 section is defined")
        elif value == "N" and 'Manual000' in self.odf_data_dic:
            logs.add(f"ERROR in {object_uid} : HasPedals=N whereas a Manual000 section is defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, True, 0, 8))
        if value != None:
            count = self.objects_type_number_get('DivisionalCoupler')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfDivisionalCouplers={value} whereas {count} DivisionalCoupler section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, 999))
        if value != None:
            count = self.objects_type_number_get('Enclosure')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfEnclosures={value} whereas {count} Enclosure section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfGenerals', ATTR_TYPE_INTEGER, True, 0, 99))
        if value != None:
            count = self.objects_type_number_get('General')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfGenerals={value} whereas {count} General section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 1, 16))
        if value != None:
            count = self.objects_type_number_get('Manual')
            if 'Manual000' in self.odf_data_dic.keys(): count -= 1
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfManuals={value} whereas {count} Manual section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfPanels', ATTR_TYPE_INTEGER, self.new_panel_format_bool, 0, 100))
        if value != None:
            count = self.objects_type_number_get('Panel')
            if 'Panel000' in self.odf_data_dic.keys(): count -= 1
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfPanels={value} whereas {count} Panel section(s) defined")

        if self.new_panel_format_bool and not 'Panel000' in self.odf_data_dic:
            logs.add("ERROR new panel format used but no Panel000 section is defined")
        elif not self.new_panel_format_bool and 'Panel000' in self.odf_data_dic:
            logs.add(f"ERROR in {object_uid} : old panel format used whereas a Panel000 is defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfReversiblePistons', ATTR_TYPE_INTEGER, True, 0, 32))
        if value != None:
            count = self.objects_type_number_get('ReversiblePiston')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfReversiblePistons={value} whereas {count} ReversiblePiston section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, 10))
        if value != None:
            count = self.objects_type_number_get('Tremulant')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfTremulants={value} whereas {count} Tremulant section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfWindchestGroups', ATTR_TYPE_INTEGER, True, 1, 999))
        if value != None:
            count = self.objects_type_number_get('WindchestGroup')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfWindchestGroups={value} whereas {count} WindchestGroup section(s) defined")

        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreIntermanualCouplers', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreIntramanualCouplers', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreTremulants', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'GeneralsStoreDivisionalCouplers', ATTR_TYPE_BOOLEAN, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'OrganBuilder', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'OrganBuildDate', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'OrganComments', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'RecordingDetails', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'InfoFilename', ATTR_TYPE_STRING, False)

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, False, 0, 999)) # old panel format
        if value != None:
            count = self.objects_type_number_get('Image')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} Image section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfLabels', ATTR_TYPE_INTEGER, False, 0, 999))  # old panel format
        if value != None:
            count = self.objects_type_number_get('Label')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfLabels={value} whereas {count} Label section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfRanks', ATTR_TYPE_INTEGER, False, 0, 999))
        if value != None:
            count = self.objects_type_number_get('Rank')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfRanks={value} whereas {count} Rank section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfSetterElements', ATTR_TYPE_INTEGER, False, 0, 999))  # old panel format
        if value != None:
            count = self.objects_type_number_get('SetterElement')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfSetterElements={value} whereas {count} SetterElement section(s) defined")

        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, 999))
        if value != None:
            count = self.objects_type_number_get('Switch')
            if count != value:
                logs.add(f"ERROR in {object_uid} : NumberOfSwitches={value} whereas {count} Switch section(s) defined")

        self.check_attribute_value(object_uid, lines_list, 'CombinationsStoreNonDisplayedDrawstops', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'Gain', ATTR_TYPE_FLOAT, False, -120, 40)
        self.check_attribute_value(object_uid, lines_list, 'PitchTuning', ATTR_TYPE_FLOAT, False, -1800, 1800)
        self.check_attribute_value(object_uid, lines_list, 'PitchCorrection', ATTR_TYPE_FLOAT, False, -1800, 1800)
        self.check_attribute_value(object_uid, lines_list, 'TrackerDelay', ATTR_TYPE_FLOAT, False, 0, 10000)
        self.check_attribute_value(object_uid, lines_list, 'Percussive', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'HasIndependentRelease', ATTR_TYPE_BOOLEAN, False)

        if not self.new_panel_format_bool:
            # if old parnel format, the Organ object contains panel attributes
            self.check_object_Panel(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Button(self, object_uid, lines_list):
        # check the data of a Button object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'ShortcutKey', ATTR_TYPE_INTEGER, False, 0, 255)
        self.check_attribute_value(object_uid, lines_list, 'StopControlMIDIKeyNumber', ATTR_TYPE_INTEGER, False, 0, 127)
        self.check_attribute_value(object_uid, lines_list, 'MIDIProgramChangeNumber', ATTR_TYPE_INTEGER, False, 1, 128)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DisplayInInvertedState', ATTR_TYPE_BOOLEAN, False)

        display_as_piston = self.check_attribute_value(object_uid, lines_list, 'DisplayAsPiston', ATTR_TYPE_BOOLEAN, False)
        if display_as_piston == '':
            # attribute not defined, set its default value
            if (object_uid.startwith(('Divisional', 'General')) or
                (object_uid[8:15] == 'Element' and self.object_attr_value_get(object_uid, 'Type') in ('Divisional', 'General'))):
                # the object is a Divisional or General button or a panel element of Divisional or General type, so it must be displayed as a piston by default
                display_as_piston = 'Y'
            else:
                display_as_piston = 'N'

        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelText', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyLabelOnLeft', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispImageNum', ATTR_TYPE_INTEGER, False, 1, 5 if display_as_piston == 'Y' else 6)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonRow', ATTR_TYPE_INTEGER, False, 0, 199)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonCol', ATTR_TYPE_INTEGER, False, 1, 32)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopRow', ATTR_TYPE_INTEGER, False, 1, 199)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCol', ATTR_TYPE_INTEGER, False, 1, 12)
        image_on = self.check_attribute_value(object_uid, lines_list, 'ImageOn', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'ImageOff', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'MaskOn', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'MaskOff', ATTR_TYPE_FILE_NAME, False)

        # get the dimensions of the parent panel
        panel_uid = self.object_parent_panel_get(object_uid)
        panel_width = myint(self.object_attr_value_get(panel_uid, 'DispScreenSizeHoriz'), 3000)
        panel_height = myint(self.object_attr_value_get(panel_uid, 'DispScreenSizeVert'), 2000)

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = myint(self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width), panel_width)
        max_height = myint(self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height), panel_height)

        # get the dimensions of the button bitmap
        if image_on not in (None, ''):
            # an image is defined to display the button
            if self.check_files_names:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.path.sep + path2ospath(image_on))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 500  # arbritrary default value
                bitmap_height = 200 # arbritrary default value
        else:
            # no image file defined, get the dimensions of the internal bitmap (piston or drawstop)
            if display_as_piston == 'Y':
                bitmap_width = bitmap_height = 32
            else:
                bitmap_width = bitmap_height = 62

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        mouse_rect_width = myint(self.check_attribute_value(object_uid, lines_list, 'MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width))
        mouse_rect_height = myint(self.check_attribute_value(object_uid, lines_list, 'MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height))

        if mouse_rect_width != None and mouse_rect_height != None:
            mouse_radius = max(mouse_rect_width, mouse_rect_height)
        else:
            mouse_radius = max(bitmap_width, bitmap_height)
        self.check_attribute_value(object_uid, lines_list, 'MouseRadius', ATTR_TYPE_INTEGER, False, 0, mouse_radius)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = myint(self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width))
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None:
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_Coupler(self, object_uid, lines_list):
        # check the data of a Coupler object section which the lines are in the given lines list

        is_coupler_obj = self.object_type_get(object_uid) == 'Coupler'

        # required attributes
        ret1 = self.check_attribute_value(object_uid, lines_list, 'UnisonOff', ATTR_TYPE_BOOLEAN, is_coupler_obj)
        ret2 = self.check_attribute_value(object_uid, lines_list, 'CouplerType', ATTR_TYPE_COUPLER_TYPE, False)  # optional but placed here to recover its value used after
        self.check_attribute_value(object_uid, lines_list, 'DestinationManual', ATTR_TYPE_INTEGER, ret1 == 'N', 0, 16) # conditional required/optional
        self.check_attribute_value(object_uid, lines_list, 'DestinationKeyshift', ATTR_TYPE_INTEGER, ret1 == 'N', -24, 24) # conditional required/optional

        is_required = (ret1 != None and ret2 != None and ret1 == 'N' and ret2.upper() not in ('MELODY', 'BASS'))
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUnisonIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUpwardIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentDownwardIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUpwardIntramanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentDownwardIntramanualCouplers', ATTR_TYPE_BOOLEAN, is_required)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'FirstMIDINoteNumber', ATTR_TYPE_INTEGER, False, 0, 127)
        self.check_attribute_value(object_uid, lines_list, 'NumberOfKeys', ATTR_TYPE_INTEGER, False, 0, 127)

        # a Coupler has in addition the attributes of a DrawStop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Divisional(self, object_uid, lines_list):
        # check the data of a Divisional object section which the lines are in the given lines list

        is_divisional_obj = self.object_type_get(object_uid) == 'Divisional'

        # recover the ID of manual in which is referenced this Divisional
        parent_manual_uid = self.object_parent_manual_get(object_uid)

        # required attributes
        max_val = myint(self.object_attr_value_get(parent_manual_uid, 'NumberOfCouplers'), 999)
        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, is_divisional_obj, 0, max_val), 0)
        for idx in range(1, value + 1):
            self.check_attribute_value(object_uid, lines_list, f'Coupler{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max_val = myint(self.object_attr_value_get(parent_manual_uid, 'NumberOfStops'), 999)
        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, is_divisional_obj, 0, max_val), 0)
        for idx in range(1, value + 1):
            self.check_attribute_value(object_uid, lines_list, f'Stop{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max_val = myint(self.object_attr_value_get(parent_manual_uid, 'NumberOfTremulants'), 10)
        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, is_divisional_obj, 0, max_val), 0)
        for idx in range(1, value + 1):
            self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Protected', ATTR_TYPE_BOOLEAN, False)

        max_val = myint(self.object_attr_value_get(parent_manual_uid, 'NumberOfSwitches'), 10)
        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max_val), 0)
        for idx in range(1, value + 1):
            self.check_attribute_value(object_uid, lines_list, f'Switch{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # a Divisional has in addition the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_DivisionalCoupler(self, object_uid, lines_list):
        # check the data of a Divisional Coupler object section which the lines are in the given lines list

        is_divisional_coupler_obj = self.object_type_get(object_uid) == 'DivisionalCoupler'

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'BiDirectionalCoupling', ATTR_TYPE_BOOLEAN, is_divisional_coupler_obj)

        max_val = myint(self.object_attr_value_get('Organ', 'NumberOfManuals'), 16)
        value = myint(self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, is_divisional_coupler_obj, 1, max_val), 0)
        for idx in range(1, value + 1):
            self.check_attribute_value(object_uid, lines_list, f"Manual{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)

        # a Divisional Coupler has in addition the attributes of a DrawStop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_DrawStop(self, object_uid, lines_list):
        # check the data of a DrawStop object section which the lines are in the given lines list

        # required attributes

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'DefaultToEngaged', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'Function', ATTR_TYPE_DRAWSTOP_FCT, False)

        max_val = myint(self.object_attr_value_get('Organ', 'NumberOfSwitches'), 999)
        switch_id = int(object_uid[-3:]) if (object_uid[-3:].isdigit() and object_uid[:-3] == 'Switch') else 999
        switch_nb = myint(self.check_attribute_value(object_uid, lines_list, 'SwitchCount', ATTR_TYPE_INTEGER, False, 1, max_val), 0)
        function = self.object_attr_value_get(object_uid, 'Function')
        if function == 'Not':
            if switch_nb > 1:
                logs.add(f'ERROR in {object_uid} section, a NOT switch cannot have more than one switch input')
            switch_nb = 1

        for idx in range(1, switch_nb + 1):
            attr_value = myint(self.check_attribute_value(object_uid, lines_list, f"Switch{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True))
            if switch_id != 999 and attr_value != None and attr_value >= switch_id:
                # the given object is a Switch and it refers to another switch which has an higher ID than it
                logs.add(f'ERROR in {object_uid} section, cannot reference a switch having an equal or higher number')
